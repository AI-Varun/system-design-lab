# Deep Dive into Object-Oriented Programming (OOP) in Java

Welcome to the foundational pillar of Low-Level Design (LLD)! Before we design complex components and their interactions, we must master Object-Oriented Programming (OOP). OOP is not just a set of language features; it's a *paradigm*, a way of thinking about and structuring code that models real-world entities or abstract concepts. This approach helps manage complexity, improve code reusability, and makes software easier to maintain and extend â€“ all critical skills for System Design.

This section provides a comprehensive guide to OOP using Java, starting from the absolute basics and progressing to more nuanced concepts. It covers essential terminology, keywords, and principles with clear explanations and code examples.

---

## ðŸ¤” Why Learn OOP Thoroughly for System Design?

In System Design interviews (both LLD and HLD), you'll constantly be thinking in terms of objects, components, and their interactions:

*   **LLD:** Designing classes like `User`, `Order`, `Product`, `PaymentGateway`, `ParkingSpot`, `ElevatorCar`. How should these classes be structured? What data should they hold? What actions can they perform? How do they relate to each other? OOP provides the tools and principles to answer these questions effectively.
*   **HLD:** While HLD focuses on architecture, the services you design (e.g., Authentication Service, Notification Service, Order Service) are often implemented using OOP principles internally. Understanding OOP helps you reason about the responsibilities and interactions of these larger components.
*   **Clean Code:** OOP (when done well) leads to code that is modular, understandable, testable, and maintainable â€“ qualities highly valued in any software engineering role.

Mastering OOP is the first crucial step towards becoming proficient in designing robust and scalable software systems.

---

## ðŸ§± The Absolute Basics: Classes and Objects

At the heart of OOP lie two fundamental concepts: Classes and Objects.

### 1. Class

*   **Concept:** A **blueprint** or template for creating objects. It defines the properties (data/attributes) and behaviors (methods/functions) that all objects of that type will share.
*   **Analogy:** Think of a `Car` blueprint. It defines that a car *has* properties like `color`, `numberOfDoors`, `maxSpeed` and *can perform* actions like `startEngine()`, `accelerate()`, `brake()`. The blueprint itself is not a car; it's the design *for* a car.
*   **Purpose:** To define the structure and behavior for a type of object, promoting organization and reusability.
*   **Keywords:** `class`
*   **Syntax:**

    ```java
    access_modifier class ClassName {
        // Fields (Attributes / Instance Variables) - Represent state
        dataType variableName1;
        dataType variableName2;
        // ...

        // Constructors - Used to initialize new objects (more later)
        ClassName(parameters) {
            // initialization logic
        }

        // Methods (Behaviors / Functions) - Represent actions
        returnType methodName1(parameters) {
            // method logic
        }
        returnType methodName2(parameters) {
            // method logic
        }
        // ...
    }
    ```
*   **Example:**

    ```java
    // Define the blueprint for a Dog
    class Dog {
        // Fields (State)
        String breed;
        int age;
        String color;

        // Methods (Behavior)
        void bark() {
            System.out.println("Woof! Woof!");
        }

        void wagTail() {
            System.out.println("Tail wagging happily!");
        }

        void displayInfo() {
            System.out.println("Breed: " + breed + ", Age: " + age + ", Color: " + color);
        }
    }
    ```

### 2. Object

*   **Concept:** An **instance** of a class. It's a concrete entity created from the class blueprint, residing in memory. Each object has its own state (values for the fields defined in the class) but shares the behavior (methods) defined by the class.
*   **Analogy:** Using the `Car` blueprint, you can build *actual* cars. One object might be a "Red Ferrari object", another a "Blue Honda object". Both are created from the `Car` blueprint, but they have different specific values for `color`, `maxSpeed`, etc. (state). They both can `startEngine()` (behavior).
*   **Purpose:** To represent individual entities within your program that hold data and can perform actions.
*   **Keywords:** `new` (used to create objects)
*   **Creating Objects:** You use the `new` keyword followed by a call to the class's constructor (we'll cover constructors shortly).

    ```java
    ClassName objectName = new ClassName(arguments_if_any);
    ```
*   **Example (using the `Dog` class):**

    ```java
    public class Zoo {
        public static void main(String[] args) {
            // Create two Dog objects (instances) from the Dog class blueprint
            Dog dog1 = new Dog(); // Create the first Dog object
            Dog dog2 = new Dog(); // Create the second Dog object

            // Set the state (attributes) for the first dog object
            dog1.breed = "Labrador";
            dog1.age = 3;
            dog1.color = "Golden";

            // Set the state for the second dog object
            dog2.breed = "Poodle";
            dog2.age = 5;
            dog2.color = "White";

            // Call methods (behavior) on the objects
            System.out.println("Dog 1 Info:");
            dog1.displayInfo(); // Output: Breed: Labrador, Age: 3, Color: Golden
            dog1.bark();        // Output: Woof! Woof!

            System.out.println("\nDog 2 Info:");
            dog2.displayInfo(); // Output: Breed: Poodle, Age: 5, Color: White
            dog2.wagTail();     // Output: Tail wagging happily!

            // Note: dog1 and dog2 are distinct objects with their own data.
        }
    }
    ```

### 3. State and Behavior (Fields and Methods)

*   **State (Attributes/Fields/Instance Variables):** Variables defined within a class that represent the data or properties of an object. Each object created from the class has its own copy of these instance variables. In the `Dog` example, `breed`, `age`, and `color` are fields representing the state.
*   **Behavior (Methods/Functions):** Functions defined within a class that represent the actions an object can perform or operations that can be done on the object's state. In the `Dog` example, `bark()`, `wagTail()`, and `displayInfo()` are methods representing behavior. Methods often operate on the object's state (fields).

---

## ðŸ”§ Essential OOP Constructs and Keywords

### 1. Constructor

*   **Concept:** A special method within a class used to **initialize** newly created objects. It's called automatically when you use the `new` keyword.
*   **Purpose:** To set the initial state of an object and perform any setup required when an object is created.
*   **Rules:**
    *   Must have the *same name* as the class.
    *   Has *no return type* (not even `void`).
*   **Types:**
    *   **Default Constructor:** If you don't define *any* constructor in a class, Java provides a default, no-argument constructor automatically that does nothing (or initializes fields to default values like 0, `null`, `false`). If you define *any* constructor, the default one is *not* provided automatically.
    *   **No-Argument Constructor:** A constructor explicitly defined with no parameters.
    *   **Parameterized Constructor:** A constructor that accepts arguments to initialize the object's fields with specific values provided during creation.
*   **Keyword:** `this` (often used inside constructors)
*   **Example:**

    ```java
    class Car {
        String model;
        int year;
        String color;

        // Parameterized Constructor
        public Car(String modelName, int productionYear, String carColor) {
            System.out.println("Parameterized Car constructor called!");
            // 'this' keyword refers to the current object being created
            this.model = modelName; // Assign argument modelName to the object's 'model' field
            this.year = productionYear;
            this.color = carColor;
        }

        // No-Argument Constructor (explicitly defined)
        public Car() {
            System.out.println("No-Argument Car constructor called!");
            // We can set default values here if needed
            this.model = "Unknown";
            this.year = 1900;
            this.color = "Black";
        }

        void displayDetails() {
            System.out.println("Model: " + this.model + ", Year: " + this.year + ", Color: " + this.color);
        }
    }

    public class Garage {
        public static void main(String[] args) {
            // Create a Car object using the parameterized constructor
            Car myCar1 = new Car("Toyota Camry", 2023, "Silver");
            // Output: Parameterized Car constructor called!
            myCar1.displayDetails();
            // Output: Model: Toyota Camry, Year: 2023, Color: Silver

            System.out.println("---");

            // Create a Car object using the no-argument constructor
            Car myCar2 = new Car();
            // Output: No-Argument Car constructor called!
            myCar2.displayDetails();
            // Output: Model: Unknown, Year: 1900, Color: Black
        }
    }
    ```

### 2. `this` Keyword

*   **Concept:** A reference variable in Java that refers to the **current object** instance within its own methods or constructor.
*   **Purpose:**
    1.  **Disambiguate Instance Variables from Parameters:** Used when method/constructor parameters have the same name as instance variables (as seen in the `Car` constructor: `this.model = modelName;`).
    2.  **Call Other Constructors (Constructor Chaining):** Use `this(...)` to call another constructor from within a constructor (must be the first statement).
    3.  **Pass the Current Object:** Pass the current object as an argument to another method.
*   **Example (Constructor Chaining):**

    ```java
    class Rectangle {
        int width;
        int height;

        // Parameterized constructor
        public Rectangle(int width, int height) {
            System.out.println("Parameterized Rectangle constructor");
            this.width = width;
            this.height = height;
        }

        // Constructor for a square (uses the other constructor)
        public Rectangle(int side) {
            // Calls the Rectangle(int width, int height) constructor of the same object
            this(side, side); // MUST be the first statement
            System.out.println("Square Rectangle constructor (using this())");
        }

        // Default constructor (calls the square constructor with default side 1)
        public Rectangle() {
            this(1); // Calls Rectangle(int side) constructor
             System.out.println("Default Rectangle constructor (using this())");
        }

        void display() {
            System.out.println("Width: " + this.width + ", Height: " + this.height);
        }
    }

    public class ShapeDemo {
        public static void main(String[] args) {
            System.out.println("Creating r1 (parameterized):");
            Rectangle r1 = new Rectangle(10, 5); // Calls Rectangle(int, int)
            r1.display(); // Width: 10, Height: 5

            System.out.println("\nCreating r2 (square):");
            Rectangle r2 = new Rectangle(7); // Calls Rectangle(int), which calls Rectangle(int, int)
            r2.display(); // Width: 7, Height: 7

            System.out.println("\nCreating r3 (default):");
            Rectangle r3 = new Rectangle(); // Calls Rectangle(), which calls Rectangle(int), which calls Rectangle(int, int)
            r3.display(); // Width: 1, Height: 1
        }
    }
    /* Output:
    Creating r1 (parameterized):
    Parameterized Rectangle constructor
    Width: 10, Height: 5

    Creating r2 (square):
    Parameterized Rectangle constructor
    Square Rectangle constructor (using this())
    Width: 7, Height: 7

    Creating r3 (default):
    Parameterized Rectangle constructor
    Square Rectangle constructor (using this())
    Default Rectangle constructor (using this())
    Width: 1, Height: 1
    */
    ```

---

## ðŸ›ï¸ The Four Pillars of OOP

These are the core principles that define the object-oriented paradigm.

### 1. Encapsulation

*   **Concept:** Bundling the data (attributes/fields) and the methods (behaviors) that operate on that data within a single unit (the class). It also crucially involves **data hiding** â€“ restricting direct access to an object's internal state from outside the class.
*   **Purpose:**
    *   **Protection:** Protects the integrity of an object's data by preventing external code from modifying it in unexpected or invalid ways.
    *   **Control:** Allows the class to control how its data is accessed and modified through specific methods (getters and setters).
    *   **Modularity:** Hides the internal implementation details, making the class a self-contained unit. Changes inside the class (e.g., how data is stored or calculated) are less likely to break other parts of the system, as long as the public interface remains the same.
    *   **Maintainability:** Makes code easier to understand and maintain because related data and behavior are grouped together.
*   **How it's Achieved:**
    *   **Access Modifiers:** Keywords that control the visibility (accessibility) of classes, fields, constructors, and methods.
        *   `private`: Accessible only *within* the same class. (Most restrictive - commonly used for fields to enforce encapsulation).
        *   `public`: Accessible from *anywhere* (other classes, packages). (Least restrictive - commonly used for constructors, methods intended for external use).
        *   `protected`: Accessible within the same class, same package, and by subclasses (even if in different packages).
        *   `default` (or package-private - no keyword): Accessible only within the *same package*.
    *   **Getters and Setters:** Public methods used to provide controlled access to private fields.
        *   **Getter (`getXxx`):** A method that returns the value of a private field.
        *   **Setter (`setXxx`):** A method that takes an argument and sets the value of a private field, often including validation logic.
*   **Example:**

    ```java
    class BankAccount {
        private String accountNumber; // Private: Cannot be accessed directly from outside
        private double balance;       // Private: Data hiding

        // Constructor
        public BankAccount(String accNum, double initialBalance) {
            this.accountNumber = accNum;
            if (initialBalance >= 0) {
                this.balance = initialBalance;
            } else {
                this.balance = 0; // Ensure balance isn't negative initially
            }
        }

        // Public Getter for balance (read access)
        public double getBalance() {
            // Could add security checks here if needed
            return this.balance;
        }

        // Public Getter for accountNumber (read access)
        public String getAccountNumber() {
            return this.accountNumber;
        }

        // Public Setter for balance is NOT provided - controlled modification via deposit/withdraw
        // We don't want anyone to just SET the balance arbitrarily.

        // Public method for controlled deposit
        public void deposit(double amount) {
            if (amount > 0) {
                this.balance += amount;
                System.out.println("Deposit successful. New balance: " + this.balance);
            } else {
                System.out.println("Deposit amount must be positive.");
            }
        }

        // Public method for controlled withdrawal
        public boolean withdraw(double amount) {
            if (amount <= 0) {
                System.out.println("Withdrawal amount must be positive.");
                return false;
            }
            if (amount <= this.balance) {
                this.balance -= amount;
                System.out.println("Withdrawal successful. New balance: " + this.balance);
                return true;
            } else {
                System.out.println("Withdrawal failed. Insufficient funds.");
                return false;
            }
        }
    }

    public class BankingApp {
        public static void main(String[] args) {
            BankAccount acc1 = new BankAccount("ACC123", 500.0);

            // Cannot access private fields directly:
            // System.out.println(acc1.balance); // COMPILE ERROR!
            // acc1.balance = 1000000;          // COMPILE ERROR!

            // Use public methods for interaction:
            System.out.println("Account: " + acc1.getAccountNumber()); // Output: Account: ACC123
            System.out.println("Initial Balance: " + acc1.getBalance()); // Output: Initial Balance: 500.0

            acc1.deposit(200.0);  // Output: Deposit successful. New balance: 700.0
            acc1.withdraw(100.0); // Output: Withdrawal successful. New balance: 600.0
            acc1.withdraw(700.0); // Output: Withdrawal failed. Insufficient funds.
            acc1.deposit(-50.0);  // Output: Deposit amount must be positive.

            System.out.println("Final Balance: " + acc1.getBalance()); // Output: Final Balance: 600.0
        }
    }
    ```

### 2. Abstraction

*   **Concept:** Hiding the complex implementation details of an object and exposing only the essential features or functionalities to the outside world. It focuses on *what* an object does rather than *how* it does it.
*   **Purpose:**
    *   **Simplicity:** Makes systems easier to understand and use by hiding unnecessary complexity. Users interact with a simplified interface.
    *   **Reduces Impact of Change:** Internal implementation details can be changed without affecting the code that uses the object, as long as the exposed interface remains consistent.
    *   **Focus:** Helps in modeling classes based on their relevant attributes and behaviors for a specific context.
*   **How it's Achieved in Java:**
    *   **Abstract Classes:**
        *   Classes declared with the `abstract` keyword.
        *   *Cannot* be instantiated directly (you can't do `new AbstractClass()`).
        *   *Can* have both abstract methods (methods without implementation, declared with `abstract`) and concrete methods (methods with implementation).
        *   Subclasses *must* implement all inherited abstract methods (unless the subclass is also abstract).
        *   Can have constructors (called via `super()` from subclasses), fields (instance and static).
        *   Use when you want to provide a common base class with some default implementation and force subclasses to provide specific implementations for certain behaviors.
    *   **Interfaces:**
        *   A completely abstract type reference declared with the `interface` keyword.
        *   *Cannot* be instantiated directly.
        *   Traditionally, interfaces could *only* contain `public static final` fields (constants) and `public abstract` methods (method signatures without implementation).
        *   Java 8+ allows `default` methods (methods with implementation that implementing classes inherit) and `static` methods within interfaces.
        *   A class `implements` an interface, inheriting its abstract methods which the class *must* implement (unless the class is abstract).
        *   A class can implement *multiple* interfaces (unlike `extends` which only allows one superclass).
        *   Use when you want to define a *contract* of capabilities (methods) that classes must adhere to, without dictating any implementation or inheritance hierarchy. Focuses purely on "what" can be done.
*   **Keywords:** `abstract`, `interface`, `implements`
*   **Example (Abstract Class):**

    ```java
    // Abstract class defining the general concept of a Shape
    abstract class Shape {
        String color;

        // Constructor (can be called by subclasses)
        public Shape(String color) {
            this.color = color;
        }

        // Concrete method (shared implementation)
        public String getColor() {
            return color;
        }

        // Abstract method (must be implemented by concrete subclasses)
        // Defines 'what' (calculate area) but not 'how'
        public abstract double calculateArea();

        // Another abstract method
        public abstract void draw();
    }

    // Concrete subclass Circle
    class Circle extends Shape {
        double radius;

        public Circle(String color, double radius) {
            super(color); // Call the Shape constructor
            this.radius = radius;
        }

        // Implement the abstract method from Shape
        @Override
        public double calculateArea() {
            return Math.PI * radius * radius;
        }

        @Override
        public void draw() {
             System.out.println("Drawing a " + getColor() + " circle with radius " + radius);
        }
    }

    // Concrete subclass Rectangle (from earlier example, now extending Shape)
    class Rect extends Shape { // Renamed to avoid conflict
        double width;
        double height;

         public Rect(String color, double width, double height) {
            super(color);
            this.width = width;
            this.height = height;
        }

        @Override
        public double calculateArea() {
            return width * height;
        }

         @Override
        public void draw() {
             System.out.println("Drawing a " + getColor() + " rectangle with width " + width + " and height " + height);
        }
    }

    public class AbstractionDemo {
        public static void main(String[] args) {
            // Cannot create an object of abstract class Shape:
            // Shape s = new Shape("Red"); // COMPILE ERROR!

            Shape circle = new Circle("Red", 5.0);
            Shape rect = new Rect("Blue", 4.0, 6.0);

            System.out.println("Circle Area: " + circle.calculateArea()); // Calls Circle's implementation
            circle.draw();

            System.out.println("Rectangle Area: " + rect.calculateArea()); // Calls Rect's implementation
            rect.draw();

            // We interact with 'Shape' objects without needing to know the exact formula used inside each subclass
        }
    }
    ```

*   **Example (Interface):**

    ```java
    // Interface defining a capability: ability to be switched on/off
    interface Switchable {
        // Methods are public abstract by default
        void turnOn();
        void turnOff();

        // Java 8+ default method
        default void printStatus(String deviceName, boolean isOn) {
             System.out.println(deviceName + " is currently " + (isOn ? "ON" : "OFF"));
        }
    }

    // Class implementing the interface
    class LightBulb implements Switchable {
        private boolean isOn = false;

        @Override
        public void turnOn() {
            isOn = true;
            System.out.println("LightBulb turned ON");
        }

        @Override
        public void turnOff() {
            isOn = false;
            System.out.println("LightBulb turned OFF");
        }

        public void checkStatus() {
             printStatus("LightBulb", isOn); // Can call default method
        }
    }

    // Another class implementing the interface
    class Fan implements Switchable {
        private boolean isSpinning = false;

        @Override
        public void turnOn() {
            isSpinning = true;
            System.out.println("Fan started spinning");
        }

        @Override
        public void turnOff() {
            isSpinning = false;
            System.out.println("Fan stopped spinning");
        }

         public void checkStatus() {
             printStatus("Fan", isSpinning); // Can call default method
        }
    }

    public class InterfaceDemo {
        public static void main(String[] args) {
            Switchable bulb = new LightBulb(); // Program to the interface
            Switchable ceilingFan = new Fan();

            bulb.turnOn();      // Output: LightBulb turned ON
            ceilingFan.turnOn(); // Output: Fan started spinning

            // Use default method via interface reference
            bulb.printStatus("Living Room Bulb", true); // Output: Living Room Bulb is currently ON

            // Accessing class-specific methods requires casting or different reference type
            ((LightBulb)bulb).checkStatus();   // Output: LightBulb is currently ON
            ((Fan)ceilingFan).checkStatus(); // Output: Fan is currently ON

            bulb.turnOff();      // Output: LightBulb turned OFF
            ceilingFan.turnOff(); // Output: Fan stopped spinning
        }
    }
    ```

### 3. Inheritance

*   **Concept:** A mechanism where a new class (subclass, derived class, child class) acquires the properties (fields) and behaviors (methods) of an existing class (superclass, base class, parent class). It represents an **"is-a"** relationship (e.g., a `Dog` *is an* `Animal`, a `SavingsAccount` *is a* `BankAccount`).
*   **Purpose:**
    *   **Code Reusability:** Avoids redundant code by defining common attributes and methods in a superclass, which subclasses can then use directly.
    *   **Hierarchy:** Establishes a natural classification or hierarchy among classes.
    *   **Polymorphism:** Enables polymorphism (discussed next), allowing objects of subclasses to be treated as objects of their superclass type.
*   **Keywords:** `extends`, `super`
    *   `extends`: Used in the subclass declaration to specify the superclass it inherits from.
    *   `super`:
        1.  `super()`: Used inside a subclass constructor to call the constructor of its immediate superclass. Must be the first statement.
        2.  `super.memberName`: Used to access members (fields or methods) of the superclass, especially when the subclass has overridden them or has members with the same name.
*   **Method Overriding:**
    *   When a subclass provides a specific implementation for a method that is already defined in its superclass.
    *   The overriding method in the subclass must have the *same name*, *same return type* (or a subtype - covariant return type), and *same parameters* as the method in the superclass.
    *   **Keyword:** `@Override` annotation: Not mandatory, but highly recommended. It tells the compiler you intend to override a superclass method. If you make a mistake (e.g., wrong method signature), the compiler will give an error, preventing subtle bugs.
*   **Example:**

    ```java
    // Superclass (Base Class)
    class Animal {
        String name;
        int age;

        // Superclass Constructor
        public Animal(String name, int age) {
            System.out.println("Animal constructor called");
            this.name = name;
            this.age = age;
        }

        public void eat() {
            System.out.println(name + " is eating.");
        }

        public void sleep() {
            System.out.println(name + " is sleeping.");
        }

        public void displayAge() {
             System.out.println(name + " is " + age + " years old.");
        }
    }

    // Subclass (Derived Class)
    class Dog extends Animal { // Dog "is-a" Animal
        String breed;

        // Subclass Constructor
        public Dog(String name, int age, String breed) {
            // Call the superclass (Animal) constructor using super()
            super(name, age); // Must be the first line
            System.out.println("Dog constructor called");
            this.breed = breed;
        }

        // Inherits eat(), sleep(), displayAge()

        // Dog-specific method
        public void bark() {
            // Accessing inherited field 'name' directly
            System.out.println(name + " the " + breed + " says Woof!");
        }

        // Method Overriding: Provide a more specific version of sleep
        @Override // Good practice annotation
        public void sleep() {
            System.out.println(name + " the dog is sleeping in its kennel.");
        }

        // Method demonstrating use of super to call superclass method
        public void animalSleep() {
            System.out.println("Calling the original Animal sleep method:");
            super.sleep(); // Calls the sleep() method from the Animal class
        }
    }

    public class InheritanceDemo {
        public static void main(String[] args) {
            System.out.println("Creating an Animal:");
            Animal genericAnimal = new Animal("Creature", 5);
            genericAnimal.eat();
            genericAnimal.sleep();
            genericAnimal.displayAge();

            System.out.println("\nCreating a Dog:");
            Dog myDog = new Dog("Buddy", 3, "Golden Retriever");
            myDog.eat();        // Inherited method
            myDog.sleep();      // Overridden method is called
            myDog.bark();       // Subclass specific method
            myDog.displayAge(); // Inherited method

            System.out.println("\nUsing super to call parent method:");
            myDog.animalSleep(); // Calls Animal's sleep via super.sleep()
        }
    }
    /* Output:
    Creating an Animal:
    Animal constructor called
    Creature is eating.
    Creature is sleeping.
    Creature is 5 years old.

    Creating a Dog:
    Animal constructor called
    Dog constructor called
    Buddy is eating.
    Buddy the dog is sleeping in its kennel.
    Buddy the Golden Retriever says Woof!
    Buddy is 3 years old.

    Using super to call parent method:
    Calling the original Animal sleep method:
    Buddy is sleeping.
    */
    ```

### 4. Polymorphism

*   **Concept:** Literally means "many forms". In OOP, it's the ability of an object to take on many forms, or more practically, the ability to treat objects of different classes (that share a common superclass or interface) in a uniform way through a reference of the superclass/interface type.
*   **Purpose:**
    *   **Flexibility & Extensibility:** Allows you to write code that can work with objects of a general type (superclass/interface) without needing to know their specific subclass type at compile time. You can easily add new subclasses that conform to the superclass/interface, and the existing code will work with them without modification (related to the Open/Closed Principle).
    *   **Simpler Code:** Reduces the need for complex `if-else` or `switch` statements based on object type.
*   **Types in Java:**
    1.  **Runtime Polymorphism (Dynamic Method Dispatch):**
        *   Achieved through **method overriding** and inheritance/interface implementation.
        *   The decision of *which* method implementation to execute (superclass's or subclass's) is made at **runtime**, based on the *actual object type*, not the reference variable type.
        *   This is the most common and powerful form of polymorphism.
    2.  **Compile-time Polymorphism (Method Overloading):**
        *   Having multiple methods within the *same class* that share the *same name* but have different **parameter lists** (different number of parameters, different types of parameters, or different order of types).
        *   The decision of which overloaded method to call is made by the compiler at **compile time**, based on the arguments provided in the method call.
        *   It's a way to provide multiple ways to call a method for convenience, not related to inheritance in the same way as overriding.
*   **Keywords:** `@Override` (related to runtime polymorphism), method signatures.
*   **Example (Runtime Polymorphism using `Animal`/`Dog` and adding `Cat`):**

    ```java
    // Continuing from Inheritance Example...
    class Cat extends Animal {
        public Cat(String name, int age) {
            super(name, age);
            System.out.println("Cat constructor called");
        }

        // Override eat() for Cat
        @Override
        public void eat() {
            System.out.println(name + " the cat is eating fish.");
        }

        // Cat-specific method
        public void meow() {
            System.out.println(name + " says Meow!");
        }
    }

    public class PolymorphismDemo {
        // This method works with ANY Animal object
        public static void makeAnimalEat(Animal animal) {
            System.out.print("Feeding time for " + animal.name + ": ");
            // Polymorphic Call: The actual method executed depends on the
            // runtime type of the object referred to by 'animal'.
            animal.eat();
        }

        public static void main(String[] args) {
            // References are of type Animal, but objects are specific subclasses
            Animal myDog = new Dog("Rex", 4, "Shepherd");
            Animal myCat = new Cat("Whiskers", 2);
            Animal generic = new Animal("Thing", 1);

            System.out.println("--- Demonstrating Polymorphism ---");
            makeAnimalEat(myDog);    // Executes Dog's inherited eat() -> Output: Feeding time for Rex: Rex is eating.
            makeAnimalEat(myCat);    // Executes Cat's overridden eat() -> Output: Feeding time for Whiskers: Whiskers the cat is eating fish.
            makeAnimalEat(generic);  // Executes Animal's eat() -> Output: Feeding time for Thing: Thing is eating.

            System.out.println("\n--- Using an Array ---");
            Animal[] pets = { myDog, myCat, new Dog("Spot", 1, "Dalmation") };

            for (Animal pet : pets) {
                pet.displayAge(); // Works polymorphically if displayAge was in Animal
                pet.eat();       // Works polymorphically

                // To call subclass-specific methods, we need instanceof and casting
                if (pet instanceof Dog) {
                    ((Dog) pet).bark();
                } else if (pet instanceof Cat) {
                    ((Cat) pet).meow();
                }
                System.out.println("-----");
            }
        }
    }
    ```

*   **Example (Compile-time Polymorphism - Method Overloading):**

    ```java
    class Calculator {
        // Method 1: Add two integers
        public int add(int a, int b) {
            System.out.println("Adding two integers");
            return a + b;
        }

        // Method 2: Add three integers (Overloaded)
        public int add(int a, int b, int c) {
            System.out.println("Adding three integers");
            return a + b + c;
        }

        // Method 3: Add two doubles (Overloaded)
        public double add(double a, double b) {
            System.out.println("Adding two doubles");
            return a + b;
        }

         // Method 4: Concatenate two strings (Overloaded - different type)
        public String add(String a, String b) {
            System.out.println("Concatenating two strings");
            return a + b;
        }
    }

    public class OverloadingDemo {
        public static void main(String[] args) {
            Calculator calc = new Calculator();

            System.out.println("Result 1: " + calc.add(5, 10));        // Calls method 1
            System.out.println("Result 2: " + calc.add(5, 10, 15));    // Calls method 2
            System.out.println("Result 3: " + calc.add(3.5, 2.1));      // Calls method 3
            System.out.println("Result 4: " + calc.add("Hello ", "World")); // Calls method 4

            // The compiler decides which 'add' method to call based on arguments.
        }
    }
    /* Output:
    Adding two integers
    Result 1: 15
    Adding three integers
    Result 2: 30
    Adding two doubles
    Result 3: 5.6
    Concatenating two strings
    Result 4: Hello World
    */
    ```

---

## âœ¨ Other Important OOP Keywords and Concepts

### 1. `static` Keyword

*   **Concept:** The `static` keyword indicates that a member (field or method) belongs to the **class itself**, rather than to any specific instance (object) of the class.
*   **Static Variables (Class Variables):**
    *   There is only *one copy* of a static variable shared among *all* objects of the class.
    *   Initialized when the class is loaded.
    *   Accessed using the class name: `ClassName.staticVariable`. (Can also be accessed via an object reference, but this is discouraged as it's misleading).
    *   Use cases: Constants shared by all instances, counters (e.g., counting how many objects are created), shared resources.
*   **Static Methods (Class Methods):**
    *   Can be called directly on the class without creating an object: `ClassName.staticMethod()`.
    *   *Cannot* access instance variables or instance methods directly (because they don't operate on a specific object instance - there's no `this` reference).
    *   *Can* access static variables and call other static methods.
    *   Use cases: Utility methods that don't depend on object state (e.g., `Math.sqrt()`, `Integer.parseInt()`), factory methods (methods that create objects).
*   **Static Blocks:** Used to initialize static variables. Executed only once when the class is loaded into memory.
*   **Example:**

    ```java
    class Thing {
        // Instance variable (each object gets its own copy)
        String name;

        // Static variable (shared by all Thing objects)
        static int count = 0; // Counter for number of objects created

        // Static block (runs once when the class is loaded)
        static {
            System.out.println("Thing class is being loaded. Initial count: " + count);
        }

        // Constructor
        public Thing(String name) {
            this.name = name;
            count++; // Increment the shared static counter
            System.out.println("Thing object created: " + name + ". Total count now: " + count);
        }

        // Instance method (operates on 'this' object)
        public void displayName() {
            System.out.println("My name is: " + this.name);
        }

        // Static method (belongs to the class)
        public static int getCount() {
            // Cannot access instance variable 'name' here:
            // System.out.println(name); // COMPILE ERROR!
            // System.out.println(this.name); // COMPILE ERROR! (no 'this')
            return count;
        }
    }

    public class StaticDemo {
        public static void main(String[] args) {
            // Access static variable/method using class name before creating objects
            System.out.println("Accessing static count via class: " + Thing.count); // Output: 0
            System.out.println("Calling static method via class: " + Thing.getCount()); // Output: 0

            System.out.println("\nCreating objects:");
            Thing t1 = new Thing("Widget");
            Thing t2 = new Thing("Gadget");
            Thing t3 = new Thing("Doohickey");

            System.out.println("\nAccessing instance methods:");
            t1.displayName(); // Output: My name is: Widget
            t2.displayName(); // Output: My name is: Gadget

            System.out.println("\nAccessing static count after creating objects:");
            // Accessing static member via class name (recommended)
            System.out.println("Final count (via Class): " + Thing.getCount()); // Output: 3
            // Accessing static member via object reference (discouraged)
            System.out.println("Final count (via t1): " + t1.count); // Output: 3 (accesses the shared variable)
            System.out.println("Final count (via t2): " + t2.getCount()); // Output: 3 (calls static method)
        }
    }
    /* Output:
    Thing class is being loaded. Initial count: 0
    Accessing static count via class: 0
    Calling static method via class: 0

    Creating objects:
    Thing object created: Widget. Total count now: 1
    Thing object created: Gadget. Total count now: 2
    Thing object created: Doohickey. Total count now: 3

    Accessing instance methods:
    My name is: Widget
    My name is: Gadget

    Accessing static count after creating objects:
    Final count (via Class): 3
    Final count (via t1): 3
    Final count (via t2): 3
    */
    ```

### 2. `final` Keyword

*   **Concept:** The `final` keyword is used to restrict modification. It can be applied to variables, methods, and classes.
*   **Final Variables:**
    *   Value *cannot be changed* once assigned. Must be initialized either at declaration or in the constructor (for instance variables) or in a static block (for static variables).
    *   Often used to create **constants** (conventionally named in `UPPER_SNAKE_CASE`), especially when combined with `static`.
    *   Example: `final int MAX_USERS = 100;` `public static final double PI = 3.14159;`
*   **Final Methods:**
    *   *Cannot be overridden* by subclasses.
    *   Use when you want to ensure a specific implementation of a method is always used and cannot be altered by inheriting classes.
*   **Final Classes:**
    *   *Cannot be subclassed* (cannot be extended).
    *   Use when you want to prevent inheritance of your class, often for security or design reasons (e.g., `String`, `Integer` are final classes in Java).
*   **Example:**

    ```java
    // Final class - cannot be extended
    final class ImmutablePoint {
        // Final instance variables - must be initialized in constructor
        private final int x;
        private final int y;
        // Static final constant
        public static final ImmutablePoint ORIGIN = new ImmutablePoint(0, 0);

        public ImmutablePoint(int x, int y) {
            this.x = x;
            this.y = y;
        }

        public int getX() { return x; }
        public int getY() { return y; }

        // Final method (implicitly final because the class is final)
        // but demonstrates the syntax if the class wasn't final
        public final String getLocation() {
            return "(" + x + ", " + y + ")";
        }
    }

    // Attempting to extend a final class - COMPILE ERROR!
    // class ExtendedPoint extends ImmutablePoint { ... }

    class Base {
        final void essentialMethod() {
            System.out.println("This is essential and cannot be changed by subclasses.");
        }
    }

    class Derived extends Base {
        // Attempting to override a final method - COMPILE ERROR!
        // @Override
        // void essentialMethod() { System.out.println("Trying to override..."); }
    }

    public class FinalDemo {
        public static void main(String[] args) {
            // Final local variable
            final int constantValue = 10;
            // constantValue = 20; // COMPILE ERROR! Cannot reassign final variable

            ImmutablePoint p1 = new ImmutablePoint(5, 3);
            System.out.println("Point 1: " + p1.getLocation());
            // p1.x = 10; // COMPILE ERROR! Cannot assign to final field 'x'

            System.out.println("Origin: " + ImmutablePoint.ORIGIN.getLocation());

            Derived d = new Derived();
            d.essentialMethod(); // Calls the final method from Base
        }
    }
    ```

### 3. Composition vs. Inheritance

*   **Inheritance ("is-a"):** Creates a relationship where a subclass *is a* specialized version of its superclass (e.g., `Dog` is an `Animal`). It's powerful for code reuse and polymorphism but can lead to rigid hierarchies and potential issues (like the Liskov Substitution Principle violation seen earlier if not careful). Changes in the superclass can unintentionally break subclasses.
*   **Composition ("has-a"):** Creates a relationship where a class *contains* an instance (or instances) of another class to utilize its functionality. The containing class *has a* reference to the contained object(s). (e.g., a `Car` *has an* `Engine`).
*   **Favor Composition Over Inheritance:** This is a common design principle. Composition often leads to more flexible and maintainable designs because:
    *   It's less rigid; you can change the "part" objects at runtime.
    *   It doesn't expose all the implementation details of the "part" class to users of the "whole" class (better encapsulation).
    *   Avoids the tight coupling of inheritance hierarchies.
    *   Helps adhere to the Single Responsibility Principle more easily.
*   **When to Use Inheritance:** Use inheritance when there's a clear "is-a" relationship, and you want to leverage polymorphism where the subclass truly *is* substitutable for the superclass.
*   **Example:**

    ```java
    // Using Composition

    // Engine is a separate component
    class Engine {
        private String type;

        public Engine(String type) { this.type = type; }
        public void start() { System.out.println("Engine (" + type + ") starting..."); }
        public void stop() { System.out.println("Engine (" + type + ") stopping..."); }
        public String getType() { return type; }
    }

    // Car HAS-A Engine (Composition)
    class CarWithEngine {
        private String model;
        private Engine engine; // Car contains an Engine object

        // Inject the Engine dependency via constructor
        public CarWithEngine(String model, Engine engine) {
            this.model = model;
            this.engine = engine; // Composition relationship established
        }

        public void startCar() {
            System.out.print(model + ": ");
            this.engine.start(); // Delegate the start action to the Engine object
        }

        public void stopCar() {
             System.out.print(model + ": ");
            this.engine.stop(); // Delegate stop action
        }

        public void displayCarInfo() {
            System.out.println("Car Model: " + model + ", Engine Type: " + engine.getType());
        }

        // Allows changing the engine later if needed (more flexible)
        public void replaceEngine(Engine newEngine) {
            System.out.println("Replacing engine in " + model);
            this.engine = newEngine;
        }
    }

    public class CompositionDemo {
        public static void main(String[] args) {
            // Create engine components
            Engine petrolEngine = new Engine("Petrol V6");
            Engine electricMotor = new Engine("Electric 100kWh");

            // Create cars using composition, injecting the engine
            CarWithEngine mySedan = new CarWithEngine("Sedan Alpha", petrolEngine);
            CarWithEngine myElectric = new CarWithEngine("SUV Beta", electricMotor);

            mySedan.startCar();    // Output: Sedan Alpha: Engine (Petrol V6) starting...
            myElectric.startCar(); // Output: SUV Beta: Engine (Electric 100kWh) starting...

            mySedan.displayCarInfo(); // Output: Car Model: Sedan Alpha, Engine Type: Petrol V6

            // Replace the engine in the Sedan
            Engine hybridEngine = new Engine("Hybrid");
            mySedan.replaceEngine(hybridEngine); // Output: Replacing engine in Sedan Alpha
            mySedan.startCar(); // Output: Sedan Alpha: Engine (Hybrid) starting...
            mySedan.displayCarInfo(); // Output: Car Model: Sedan Alpha, Engine Type: Hybrid
        }
    }
    ```

---

## ðŸš€ Conclusion and Next Steps

You have now covered the essential building blocks, keywords, and core principles of Object-Oriented Programming in Java:

*   **Basics:** Class, Object, State (Fields), Behavior (Methods)
*   **Constructs:** Constructor, `this`
*   **Pillars:** Encapsulation (Access Modifiers, Getters/Setters), Abstraction (`abstract class`, `interface`), Inheritance (`extends`, `super`, Method Overriding), Polymorphism (Runtime/Overriding, Compile-time/Overloading)
*   **Keywords:** `static`, `final`
*   **Concepts:** Composition vs. Inheritance

A solid understanding of these concepts is absolutely crucial before moving forward. They are the language you will use to describe and implement the components in Low-Level Design problems.

With this foundation, you are now well-prepared to explore **Design Patterns** (Creational, Structural, Behavioral) in the next section. Design patterns are proven, reusable solutions to common software design problems, and they heavily leverage the OOP principles you've just learned.

Proceed to **Section 1.2: LLD Core Building Blocks: Design Patterns**.